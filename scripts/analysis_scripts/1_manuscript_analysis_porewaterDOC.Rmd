---
title: "Porewater DOC Manuscript Analysis"
author: "AMP"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(lubridate)
library(tidyverse)
library(car)
library(emmeans)
library(lme4)
library(lmerTest)  
library(ggplot2)    # For diagnostic plots
library(broom)      # For tidy model outputs

#double check your wd
getwd()

#clean out your environment 
rm(list = ls())
```

### Set the study dates

```{r event and study dates}
endstudydate = lubridate::as_date("2024-01-31")
startstudydate = lubridate::as_date("2022-05-01")

endstudydate_yr1 = lubridate::as_date("2023-05-31")
startstudydate_yr1 = lubridate::as_date("2022-05-01")

endstudydate_yr2 = lubridate::as_date("2024-05-31")
startstudydate_yr2 = lubridate::as_date("2023-05-01") 

endstudydate_yr3 = lubridate::as_date("2025-05-31")
startstudydate_yr3 = lubridate::as_date("2024-05-01") 

year1_start = lubridate::as_date("2022-01-01")
year1_stop = lubridate::as_date("2022-12-31")

year2_start = lubridate::as_date("2023-01-01")
year2_stop = lubridate::as_date("2023-12-31")

year3_start = lubridate::as_date("2024-01-01")
year3_stop = lubridate::as_date("2024-12-31")

EventStart2022 = lubridate::as_date("2022-06-22")

WaterDeliveryStart2022 = as.POSIXct("2022-06-22 05:30:00", tz = "EST")
WaterDeliveryStop2022 = as.POSIXct("2022-06-22 14:30:00", tz = "EST")

EventStart2023 = lubridate::as_date("2022-06-06")

WaterDeliveryStart1 = as.POSIXct("2023-06-06 05:30:00", tz = "EST")
WaterDeliveryStop1 = as.POSIXct("2023-06-06 14:30:00", tz = "EST")

WaterDeliveryStart2 = as.POSIXct("2023-06-07 05:30:00", tz = "EST")
WaterDeliveryStop2 = as.POSIXct("2023-06-07 14:30:00", tz = "EST")

WaterDeliveryStart1_2024 = as.POSIXct("2024-06-11 06:10:00", tz = "EST")
WaterDeliveryStart2_2024 = as.POSIXct("2024-06-12 06:08:00", tz = "EST")
WaterDeliveryStart3_2024 = as.POSIXct("2024-06-13 06:21:00", tz = "EST")

plot_order <- c('Control', 'Freshwater','Saltwater')
time_order <- c('Pre', 'Mid','Post')
```

### Read in DOC data

1) Import DOC grid data for porewater from 2022, 2023 and 2024 events. Then, bind them together and take the average and standard deviation of the values for each event. Do this by the evacuation date, as this will capture multiple tries within the same dateframe. For this particular analysis, it's ok to take the average of the date time of sampling, because we're just going to be using this data to plot through time and do some simple summary statistics.  

```{r read in doc}

#Porewater DOC data, from L1 google drive: 

doc_l1_2022 <- read_csv("~/GitHub/TEMPEST-1-porewater/processed data/for_google_drive/TMP_PW_GRIDSONLY_NPOCTDN_2022_L1.csv")
  
doc_l1_2023 <- read_csv("~/GitHub/TEMPEST-1-porewater/processed data/for_google_drive/TMP_PW_GRIDSONLY_NPOCTDN_2023_L1.csv")

doc_l1_2024 <- read_csv("~/GitHub/TEMPEST_Porewater/processing_scripts/DOC/TEMPORARY/01_TMP_PW_NPOCTDN_2024_L1.csv")

doc_l1_2025 <- read_csv("~/GitHub/TEMPEST_Porewater/processing_scripts/DOC/TEMPORARY/01_TMP_PW_NPOCTDN_2025_L1.csv")
```
```{r combine years}
doc_l1_pw_grids <- doc_l1_2022 %>%
  full_join(doc_l1_2023) %>%
  full_join(doc_l1_2024) %>%
  full_join(doc_l1_2025) %>%
  mutate(evacuation_date = as_date(evacuation_datetime)) %>%
  select(plot, grid, evacuation_date, collection_datetime, doc_mg_l, tdn_mg_l) %>%
  drop_na() #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
```

# Main Message 1: One salinity exposure permanently changes the soil DOC component of the carbon cycle. 

### Prep data for figure 1: Porewater DOC averages/std by plot and month
Generate for easy comparison between event years and with laboratory data sets.
Can simplify this from previous iterations (see `graveyard_analysis_code.Rmd`) because we just want a monthly timeframe. 
```{r doc avg std by month YEAR 1}

pw_doc_yr1 <- doc_l1_2022 %>%
  mutate(date = as_date(date)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr1, endstudydate)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  # fix the sampling dates in June before the event to the month before
  mutate(adj_month = case_when(adj_month == 1 & date < EventStart2022 ~ adj_month == 0,
                               TRUE ~ adj_month)) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

pw_doc_yr1_2023 <- doc_l1_2023 %>%
  mutate(date = as_date(date)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr1, endstudydate_yr1)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  mutate(adj_month = case_when(adj_month == 0 ~ 12,
                               TRUE ~ adj_month )) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

pw_doc_y1_all <- pw_doc_yr1 %>%
  full_join(pw_doc_yr1_2023)
  

saveRDS(pw_doc_y1_all, "~/GitHub/TEMPEST-1-porewater/data/averaged_doc_porewater_TMP1_Figure1.rds")
```

```{r doc avg std by month YEAR 2}


pw_doc_yr2 <- doc_l1_2023 %>%
  mutate(date = as_date(evacuation_datetime)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr2, endstudydate_yr2)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  # fix the sampling dates in June before the event to the month before
  mutate(adj_month = case_when(adj_month == 1 & date < EventStart2023 ~ adj_month == 0,
                               TRUE ~ adj_month)) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

pw_doc_yr2_2024 <- doc_l1_2024 %>%
  mutate(date = as_date(date)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr2, endstudydate_yr2)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  mutate(adj_month = case_when(adj_month == 0 ~ 12,
                               TRUE ~ adj_month )) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

pw_doc_y2_all <- pw_doc_yr2 %>%
  full_join(pw_doc_yr2_2024)

  

saveRDS(pw_doc_y2_all, "~/GitHub/TEMPEST-1-porewater/data/averaged_doc_porewater_TMP2_Figure1.rds")
```

```{r doc avg std by month YEAR 3}


pw_doc_yr3 <- doc_l1_2024 %>%
  mutate(date = as_date(evacuation_datetime)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr3, endstudydate_yr3)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  # fix the sampling dates in June before the event to the month before
  mutate(adj_month = case_when(adj_month == 1 & date < EventStart2023 ~ adj_month == 0,
                               TRUE ~ adj_month)) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

  
pw_doc_yr3_2025 <- doc_l1_2025 %>%
  mutate(date = as_date(date)) %>%
  select(plot, grid, date, doc_mg_l, tdn_mg_l) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr3, endstudydate_yr3)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  mutate(adj_month = case_when(adj_month == 0 ~ 12,
                               TRUE ~ adj_month )) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, doc_mg_l, tdn_mg_l, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

pw_doc_y3_all <- pw_doc_yr3 %>%
  full_join(pw_doc_yr3_2025)

  

saveRDS(pw_doc_y3_all, "~/GitHub/TEMPEST-1-porewater/data/averaged_doc_porewater_TMP3_Figure1.rds")
```



# Main Message 2: The possible mechanisms at play here are all changing in concert, which clouds predictability across systems and scales.


### ANALYSIS: When does saltwater plot DOC go out of "normal" variablity?  

```{r doc change analysis}

#1. calculate control plot baseline 

baseline <- doc_l1_pw_grids %>%
  filter(plot == "Control") %>%
  group_by(evacuation_date) %>%
  summarize(
    baseline_mean = mean(doc_mg_l, na.rm = TRUE),
    baseline_sd = sd(doc_mg_l, na.rm = TRUE) # Include standard deviation for later analysis
  ) 

max_sd <- max(baseline$baseline_sd, na.rm= TRUE)
                                   

# 2. Combine baseline data with saltwater data for comparison.
comparison <- doc_l1_pw_grids  %>%
  filter(plot == "Saltwater") %>%
  group_by(evacuation_date) %>%
  summarize(
    doc_median = median(doc_mg_l, na.rm = TRUE),
    doc_sd = sd(doc_mg_l, na.rm = TRUE) 
  ) %>%
  ungroup()%>%
  left_join(baseline, by = "evacuation_date") %>%
  mutate(baseline_mean = case_when(is.na(baseline_mean) ~ mean(baseline_mean, na.rm =TRUE),
                                   TRUE ~ baseline_mean),
         baseline_sd = case_when(is.na(baseline_sd) ~ max_sd,
                                 TRUE ~ baseline_sd)) %>%
  mutate(
    # Calculate the deviation of saltwater analyte concentration from baseline.
    deviation = doc_median - baseline_mean,
    # Flag dates where the saltwater concentration is significantly higher than baseline
    flag_high_change = deviation > (3 * baseline_sd) # Adjust multiplier based on your needs
  )

# Inspect the comparison dataset
print(comparison)

# 3. Extract the dates where there is a "significant change" in the saltwater plot.
significant_dates <- comparison %>%
  filter(flag_high_change) %>%
  select(evacuation_date, doc_median , deviation) %>%
  mutate(year = lubridate::year(evacuation_date)) %>%
  ungroup()

print(significant_dates)

# 4. Get the "first" date post event each year. 

tmp1_first_dates <- significant_dates %>% 
  filter(year == "2022") %>%
  filter(evacuation_date == min(evacuation_date))

tmp2_first_dates <- significant_dates %>% 
  filter(year == "2023") %>%
  filter(evacuation_date > WaterDeliveryStop2) %>%
  filter(evacuation_date == min(evacuation_date))

tmp3_first_dates <- significant_dates %>% 
  filter(year > 2023) %>%
  filter(evacuation_date > WaterDeliveryStart3_2024) %>%
  filter(evacuation_date == min(evacuation_date))

tmpdates_doc.1 <- tmp1_first_dates %>%
  full_join(tmp2_first_dates ) %>%
  full_join(tmp3_first_dates)


collection_dates <- doc_l1_pw_grids %>%
  filter(plot == "Saltwater") %>%
  filter(evacuation_date %in% tmpdates_doc$evacuation_date) %>%
  select(evacuation_date, collection_datetime) %>%
  group_by(evacuation_date) %>%
  summarise(collection_datetime = min(collection_datetime)) %>%
  ungroup()

tmpdates_doc <-  tmpdates_doc.1 %>%
  full_join(collection_dates, by= "evacuation_date")

tmpdates_doc 

 saveRDS(tmpdates_doc, "~/GitHub/TEMPEST-1-porewater/data/dates_DOC_higher_than_variance.rds")
```


### Conductivity: What is the conductivity values when DOC is high? 

What is the conductivity when this happens?
- bring in teros conductivity plot averages to ID conductivity values when DOC is high

```{r teros EC}

pw_grids_ec <- read_rds("~/GitHub/TEMPEST-1-porewater/processed data/TMP_PW_EC_15cm_2021-2025_L2.rds")

pw_plot_ec <- pw_grids_ec %>%
  group_by(plot, depth, research_name, datetime_est, yday(datetime_est)) %>%
        summarise(datetime_est = mean(datetime_est),
                  EC_uScm = mean(value, na.rm = TRUE),
                  .groups = "drop")

# write out for plotting:
saveRDS(pw_plot_ec, "~/GitHub/TEMPEST-1-porewater/data/averaged_by_plot_ec_teros_porewater.rds")

```

Mean plot conductivity values when DOC has reached 10x SD of control plot. 

```{r cond threshold}
dates_4_cond <- tmpdates_doc %>%
  mutate(date = lubridate::date(collection_datetime))

cond_doc_thres <- pw_plot_ec %>%
  filter(plot == "Saltwater") %>%
  mutate(date = lubridate::date(datetime_est)) %>%
  group_by(plot, depth, research_name, date) %>%
  filter(date %in% dates_4_cond$date) %>%
  ungroup() %>%
  summarise(EC_uScm_mean = mean(EC_uScm, na.rm = TRUE),
                  EC_uScm_sd = sd(EC_uScm, na.rm = TRUE),
                  .groups = "drop")

cond_doc_thres

```


### pH: What is the relationship between pH and DOC after each event? 

We can do this analysis a bit differently than conductivity since we should have directly paired datasets.

1. Plot level pH averages and stds
```{r load pH data}

ph_2023 <-  read_csv("~/GitHub/TEMPEST-1-porewater/processed data/for_google_drive/TMP_PW_pH_2023_L1.csv") 
ph_2024 <-  read_csv("~/GitHub/TEMPEST-1-porewater/processed data/for_google_drive/TMP_PW_pH_2024_L1.csv") 
ph_2025 <-  read_csv("~/GitHub/TEMPEST-1-porewater/processed data/for_google_drive/TMP_PW_pH_2025_L1.csv") 

```

```{r ph all years}
ph_l1_pw_grids <- ph_2023 %>%
  full_join(ph_2024) %>%
  full_join(ph_2025) %>%
  dplyr::select(plot, datetime, evacuation_date, pH) %>%
  drop_na() %>%
  mutate(date = lubridate::date(datetime)) %>%
  group_by(plot, evacuation_date)
  
```

Mean plot pH values when DOC has reached 10x SD of control plot. 

```{r ph threshold}
dates_4_ph <- tmpdates_doc %>%
  mutate(date = lubridate::date(collection_datetime))

ph_doc_thres <- ph_l1_pw_grids %>%
  filter(plot == "Saltwater") %>%
  mutate(date = lubridate::date(datetime)) %>%
  group_by(plot, date) %>%
  filter(date %in% dates_4_ph$date) %>%
  ungroup() %>%
  summarise(pH_mean = mean(pH, na.rm = TRUE),
                  pH_sd = sd(pH, na.rm = TRUE),
                  .groups = "drop")

ph_doc_thres

```

2 a. ph time series plots

```{r ph avg std for timeseries plots}
# Some dates not enough water was collected to have multiple samples to get averages and sds for that evacuation period. Most of the time, those can be combined with sampling dates just before or just after as we go out over several multi-day periods. This, however isn't consistent across the FW, EW, or C plots, so it will be a bit tricky to do the gap filling. To make the gap filling more accurate, we'll take the average of those dates, so for example if the dates we're merging is 2022-11-25 and 2022-11-28 we'll have the date be the 26th (but we'll let R do that math).

#First, isolate the trouble dates/times: 

#Control: 
mean_ph_l1_c_to_gapfill <- ph_l1_pw_grids %>%
  filter(plot == "Control") %>%
  filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-07-05") | str_detect(evacuation_date,"2023-07-07") ~ "B",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "C",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "D",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    dplyr::summarise(across(everything(), mean), .groups = "keep") %>%
  mutate(datetime = as.POSIXct(datetime, origin = "1970-01-01"),
         evacuation_date = as_date(evacuation_date)) %>%
  ungroup()%>%
  dplyr::select(-date)

sd_ph_l1_c_to_gapfill <- ph_l1_pw_grids %>%
  select(-datetime) %>%
  filter(plot == "Control") %>%
 filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-07-05") | str_detect(evacuation_date,"2023-07-07") ~ "B",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "C",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "D",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    select(-evacuation_date) %>%
    dplyr::summarise(across(everything(), sd), .groups = "keep") %>%
  rename(pH_sd = pH) %>%
    ungroup() %>%
  dplyr::select(-date)

ph_c_gapfill <- mean_ph_l1_c_to_gapfill %>%
  full_join(sd_ph_l1_c_to_gapfill, by = c("plot", "gapfill_group")) %>%
  select(-gapfill_group)

#Freshwater: 
mean_ph_l1_fw_to_gapfill <- ph_l1_pw_grids %>%
  filter(plot == "Freshwater") %>%
  filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "B",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "C",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    dplyr::summarise(across(everything(), mean), .groups = "keep") %>%
  mutate(datetime = as.POSIXct(datetime, origin = "1970-01-01"),
         evacuation_date = as_date(evacuation_date)) %>%
  ungroup()%>%
  dplyr::select(-date)

sd_ph_l1_fw_to_gapfill <- ph_l1_pw_grids %>%
  select(-datetime) %>%
  filter(plot == "Freshwater") %>%
  filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "B",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "C",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    select(-evacuation_date) %>%
    dplyr::summarise(across(everything(), sd), .groups = "keep") %>%
  rename(pH_sd = pH) %>%
    ungroup() %>%
  dplyr::select(-date)

ph_fw_gapfill <- mean_ph_l1_fw_to_gapfill %>%
  full_join(sd_ph_l1_fw_to_gapfill, by = c("plot", "gapfill_group")) %>%
  select(-gapfill_group)

#Seawater: 
mean_ph_l1_sw_to_gapfill <- ph_l1_pw_grids %>%
  filter(plot == "Saltwater") %>%
  filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-09-29", "2023-10-02", "2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-07-05") | str_detect(evacuation_date,"2023-07-07") ~ "B",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "C",
    str_detect(evacuation_date,"2023-09-29") | str_detect(evacuation_date,"2023-10-02") ~ "D",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "E",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    dplyr::summarise(across(everything(), mean), .groups = "keep") %>%
  mutate(datetime = as.POSIXct(datetime, origin = "1970-01-01"),
         evacuation_date = as_date(evacuation_date)) %>%
  ungroup()%>%
  dplyr::select(-date)

sd_ph_l1_sw_to_gapfill <- ph_l1_pw_grids %>%
  select(-datetime) %>%
  filter(plot == "Saltwater") %>%
  filter(evacuation_date %in% c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-09-29", "2023-10-02", "2023-12-05", "2023-12-08")) %>%
  mutate(gapfill_group = case_when( 
    str_detect(evacuation_date,"2023-06-12") | str_detect(evacuation_date,"2023-06-14") ~ "A",
    str_detect(evacuation_date,"2023-07-05") | str_detect(evacuation_date,"2023-07-07") ~ "B",
    str_detect(evacuation_date,"2023-08-04") | str_detect(evacuation_date,"2023-08-07") ~ "C",
    str_detect(evacuation_date,"2023-09-29") | str_detect(evacuation_date,"2023-10-02") ~ "D",
    str_detect(evacuation_date,"2023-12-05") | str_detect(evacuation_date,"2023-12-08") ~ "E",
    TRUE ~ "no")) %>%
   group_by(plot, gapfill_group) %>%
    select(-evacuation_date) %>%
    dplyr::summarise(across(everything(), sd), .groups = "keep") %>%
  rename(pH_sd = pH) %>%
    ungroup() %>%
  dplyr::select(-date)

ph_sw_gapfill <- mean_ph_l1_sw_to_gapfill %>%
  full_join(sd_ph_l1_sw_to_gapfill, by = c("plot", "gapfill_group")) %>%
  select(-gapfill_group)

##
#All the rest: 
means_ph_l1_pw_grids <- ph_l1_pw_grids %>%
filter(plot != "Control" | 
    (plot == "Control" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")))) %>%
  filter(plot != "Saltwater" | 
    (plot == "Saltwater" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-09-29", "2023-10-02", "2023-12-05", "2023-12-08")))) %>%
    filter(plot != "Freshwater" | 
    (plot == "Freshwater" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")))) %>%
  mutate(evacuation_date = as.numeric(evacuation_date),
         datetime= as.numeric(datetime)) %>%
  group_by(plot, evacuation_date) %>%
  dplyr::summarise(across(everything(), mean), .groups = "keep") %>%
  mutate(datetime = as.POSIXct(datetime, origin = "1970-01-01"),
         evacuation_date = as_date(evacuation_date))


sds_ph_l1_pw_grids <- ph_l1_pw_grids %>%
  select(-datetime) %>%
 filter(plot != "Control" | 
    (plot == "Control" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")))) %>%
  filter(plot != "Saltwater" | 
    (plot == "Saltwater" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-07-05", "2023-07-07", "2023-08-04", "2023-08-07","2023-09-29", "2023-10-02", "2023-12-05", "2023-12-08"))))  %>%
    filter(plot != "Freshwater" | 
    (plot == "Freshwater" & !evacuation_date %in% as.Date(c("2023-06-12", "2023-06-14", "2023-08-04", "2023-08-07","2023-12-05", "2023-12-08")))) %>%
  mutate(evacuation_date = as.numeric(evacuation_date)) %>%
  group_by(plot, evacuation_date) %>%
  dplyr::summarise(across(everything(), sd), .groups = "keep") %>%
  mutate(evacuation_date = as_date(evacuation_date)) %>%
  rename(pH_sd = pH) %>%
  dplyr::select(-date)

merging_dfs <- list(means_ph_l1_pw_grids, sds_ph_l1_pw_grids, ph_c_gapfill, ph_sw_gapfill, ph_fw_gapfill)

pw_ph <- purrr::reduce(merging_dfs, full_join) %>%
   dplyr::select(-date)

# write out for plotting:
saveRDS(pw_ph, "~/GitHub/TEMPEST-1-porewater/data/averaged_ph_porewater.rds")

#note this has two dates close in 2025 that we might need to merge together at some point 
```

2 b. Now, get pH at the level as the DOC in terms of per month 

```{r ph avg std by month YEAR 2}


ph_yr2 <-  ph_2023 %>%
  mutate(date = as_date(datetime)) %>%
  select(plot, grid, date, pH) %>%
  drop_na() %>% 
  filter(between(date, startstudydate_yr2, endstudydate_yr2)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  # fix the sampling dates in June before the event to the month before
  mutate(adj_month = case_when(adj_month == 1 & date < EventStart2023 ~ adj_month == 0,
                               TRUE ~ adj_month)) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, pH, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

ph_yr2_2024 <- ph_2024 %>%
  mutate(date = as_date(datetime)) %>%
  select(plot, grid, date, pH) %>%
  drop_na() %>% #
  filter(between(date, startstudydate_yr2, endstudydate_yr2)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  mutate(adj_month = case_when(adj_month == 0 ~ 12,
                               TRUE ~ adj_month )) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, pH, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

ph_y2_all <- ph_yr2 %>%
  full_join(ph_yr2_2024)

  

saveRDS(ph_y2_all, "~/GitHub/TEMPEST-1-porewater/data/averaged_ph_porewater_TMP2.rds")
```

```{r ph avg std by month YEAR 3}


ph_yr3 <- ph_2024 %>%
  mutate(date = as_date(datetime)) %>%
  select(plot, grid, date, pH) %>%
  drop_na() %>% 
  filter(between(date, startstudydate_yr3, endstudydate_yr3)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  # fix the sampling dates in June before the event to the month before
  mutate(adj_month = case_when(adj_month == 1 & date < EventStart2023 ~ adj_month == 0,
                               TRUE ~ adj_month)) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, pH, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

  
ph_yr3_2025 <- ph_2025 %>%
  mutate(date = as_date(datetime)) %>%
  select(plot, grid, date, pH) %>%
  drop_na() %>% #dont need to specify column here because the only ones with NAs are DOC or TDN and they are both NA at the same time.
  filter(between(date, startstudydate_yr3, endstudydate_yr3)) %>%
  mutate(year = lubridate::year(date), 
         month = lubridate::month(date),
           # Adjust months: May = 0, June = 1, ..., April = 11
         adj_month = (month(date) - 5) %% 12 ) %>%
  mutate(adj_month = case_when(adj_month == 0 ~ 12,
                               TRUE ~ adj_month )) %>%
  group_by(adj_month, year, plot) %>%
  dplyr::select(plot, pH, adj_month, year) %>%
  dplyr::summarise(across(everything(), list(mean = ~mean(.), sd = ~sd(.))), .groups = "keep") %>%
   ungroup()

ph_y3_all <- ph_yr3 %>%
  full_join(ph_yr3_2025)

  

saveRDS(ph_y3_all, "~/GitHub/TEMPEST-1-porewater/data/averaged_ph_porewater_TMP3.rds")
```

# Experimental Data Analysis for mechanistic relationships
Workflow 
1) Exploratory Data Analysis: look at DOC vs driver variable relationships in the ColEx data 
2) Bring in a priori hypothesis-based knowledge from table of mechanisms to reduce variable numbers.  https://docs.google.com/spreadsheets/d/1DHOeCKPpyUJbPBAVBy6-vegGymVbECd7rN9bFWm7Y0M/edit?usp=sharing
3) Try Bayesian Networks to discover probabilistic causal structures with bnlearn 
  3a) scale data (try z-scores)
  3b) check multicollinearity with VIFs
  3c) include mechanistic constraints (e.g., Fe/OC influence DOC)
  
### Exploratory data analysis

```{r load ColEx data}
ColEx <- read_excel("~/GitHub/tempest_ionic_strength/Data/Exp 3 Column Experiment ColEx Data/ColEx_data_allreps_formatted.xlsx") %>% #drop initial for this
  filter(Timepoint != 0)

```

```{r exploratory data analysis}
library(ggcorrplot)

ColEx_corr <- ColEx %>%
  select(-Treatment, -Column, - Timepoint)

cor_matrix <- cor(ColEx_corr, use = "complete.obs")

ggcorrplot(cor_matrix)

```
There are no other variables that stick out than the ones we'd pick a priori that are highly correlated to DOC. 


```{r check lags}
# Check lagged correlations
library(tseries)
ccf(ColEx$pH, ColEx$doc_mgperL, lag.max = 12)
ccf(ColEx$conductivity_uSpercm, ColEx$doc_mgperL, lag.max = 12)

```
 Interpretation:
 - Check lag 0: Strong direct correlation between variable and DOC at the same time point.
 - Lags > 0: Positive correlations here mean variable changes precede DOC changes by the lag amount.
 - Lags < 0: Negative correlations here mean DOC changes precede variable changes by the lag amount.
 - Dashed horizontal lines = confidence bounds, significant correlations occur when values go beyond those lines.

This analysis might be really cool to do with the actual plot data and not the experiment- going to leave out of the model here. 

Narrow down to final variables


```{r check colinearity}
library(car)

# Fit a linear model to check VIF
lm_model <- lm(DOC ~ pH + Fe_OC_ratio + Conductivity, data = scaled_data)
car::vif(lm_model)

# General guideline: VIF > 10 indicates problematic multicollinearity
```


```{r do the Dynamic Bayesian Networks}

library(bnlearn)

# Whitelist specific relationships based on prior knowledge
whitelist <- data.frame(
  from = c("Fe_OC_ratio", "pH"),
  to = c("DOC", "DOC")
)

dag <- hc(data, whitelist = whitelist)
plot(dag)



